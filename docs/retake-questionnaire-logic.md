# Логика перепрохождения анкеты и перегенерации плана

## Процесс перепрохождения анкеты

### 1. Обновление профиля
- При перепрохождении анкеты (когда `existingProfile` существует):
  - Профиль обновляется с **новой версией** (`version + 1`)
  - Сохраняются некоторые данные из старого профиля (например, `gender`, `ageGroup`)
  - Медицинские маркеры объединяются (старые + новые)

### 2. Очистка старых данных
- **Удаляется старая RecommendationSession** (по `userId`)
  ```typescript
  await prisma.recommendationSession.deleteMany({
    where: { userId },
  });
  ```
- **Очищается кэш** для старой и новой версии профиля
  ```typescript
  await invalidateCache(userId, existingProfile.version);
  await invalidateCache(userId, profile.version);
  ```

### 3. Создание новой RecommendationSession
- Система ищет **подходящее правило рекомендаций** (`RecommendationRule`):
  - Правила проверяются по условиям профиля (тип кожи, concerns, диагнозы и т.д.)
  - Выбирается первое подходящее правило
  
- Для каждого шага из правила (`stepsJson`) подбираются продукты:
  - Используется функция `getProductsForStep` из `@/lib/product-selection`
  - Учитываются параметры:
    - **Бюджет пользователя** (из ответа на вопрос `budget`)
    - **Тип кожи** (normal, dry, oily, combo, sensitive)
    - **Concerns** (акне, пигментация, морщины и т.д.)
    - **Активные ингредиенты** (указанные в правиле)
    - **Фильтры**: `is_non_comedogenic`, `is_fragrance_free`, `is_natural`
  
- Если продуктов недостаточно, используется **fallback поиск**:
  - Более мягкие условия поиска
  - Убираются фильтры по типу кожи и concerns
  - Расширенный поиск по категориям

- Создается новая `RecommendationSession`:
  ```typescript
  await prisma.recommendationSession.create({
    data: {
      userId,
      profileId: profile.id, // Новая версия профиля
      ruleId: matchedRule.id,
      products: productIds, // Массив ID продуктов
    },
  });
  ```

### 4. Генерация плана
- План генерируется **синхронно** после создания профиля
- Функция `generate28DayPlan`:
  1. Получает профиль кожи
  2. Выбирает шаблон плана ухода (`CarePlanTemplate`) на основе:
     - Типа кожи
     - Основных целей (`mainGoals`)
     - Уровня чувствительности
     - Сложности рутины
  3. **Использует продукты из RecommendationSession**:
     - Ищет сессию для текущего профиля (`profileId`)
     - Если в сессии достаточно продуктов (≥ 3), использует их
     - Если продуктов недостаточно, использует fallback логику
  4. Обеспечивает наличие всех требуемых шагов:
     - Использует `ensureRequiredProducts` для добавления недостающих продуктов
     - Использует `findFallbackProductsBatch` для поиска продуктов для недостающих шагов
  5. Сохраняет план в кэш

## Важные моменты

### RecommendationSession vs План
- **RecommendationSession создается из правил рекомендаций** (`/api/questionnaire/answers`)
- **План читает из RecommendationSession**, но не перезаписывает её
- Это гарантирует консистентность между главной страницей и планом

### Порядок операций при перепрохождении
1. Сохранение новых ответов
2. Обновление профиля (новая версия)
3. Удаление старой RecommendationSession
4. Очистка кэша
5. Создание новой RecommendationSession (на основе новых ответов и правил)
6. Генерация нового плана (использует новую RecommendationSession)
7. Сохранение плана в кэш

### Подбор продуктов
- Используется та же логика, что и на главной странице (`/api/recommendations`)
- Учитывается бюджет пользователя
- Приоритет: `isHero` > `priority` > `createdAt`
- Если продуктов недостаточно, используется fallback поиск








