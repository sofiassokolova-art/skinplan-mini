import React, { useEffect, useMemo, useState } from "react";
import { STEPS } from "../data/steps";
import { loadAnswers, saveAnswers } from "../lib/storage";
import { Card, Button } from "../ui";

const cx = (...a: Array<string | false | undefined | null>) => a.filter(Boolean).join(" ");
type Answers = Record<string, any>;

/** Нормализованный шаг для рендера */
type NStep =
  | { type: "text"; id: string; title: string; subtitle?: string; placeholder?: string }
  | { type: "single"; id: string; title: string; subtitle?: string; options: string[] }
  | { type: "multi"; id: string; title: string; subtitle?: string; options: string[]; limit?: number }
  | { type: "scale"; id: string; title: string; subtitle?: string; min?: number; max?: number }
  | { type: "insight"; id: string; title: string; body: React.ReactNode | ((a: Answers) => React.ReactNode) };

/** Приводим старые формы шагов к единому виду */
function normalizeStep(raw: any): NStep | null {
  if (!raw) return null;

  // Новая схема — уже нормальная
  if (["text", "single", "multi", "scale", "insight"].includes(raw.type)) {
    return raw as NStep;
  }

  // Старая схема: { type: "q"|"block"|"insight", kind?, options?, ... }
  if (raw.type === "q") {
    const title = raw.title || raw.t || "";
    const subtitle = raw.subtitle || raw.s || "";
    const id = raw.id || raw.key || `q_${title}`;
    if (raw.kind === "single")    return { type: "single", id, title, subtitle, options: raw.options || [] };
    if (raw.kind === "multi")     return { type: "multi",  id, title, subtitle, options: raw.options || [], limit: raw.limit };
    if (raw.kind === "text")      return { type: "text",   id, title, subtitle, placeholder: raw.placeholder || "" };
    if (raw.kind === "scale" || raw.kind === "slider") {
      return { type: "scale", id, title, subtitle, min: raw.min ?? 0, max: raw.max ?? 10 };
    }
    // По умолчанию — текст
    return { type: "text", id, title, subtitle };
  }

  if (raw.type === "block") {
    // старый "экран между вопросами" — отрендерим как инсайт
    const id = raw.id || `block_${raw.title || "step"}`;
    const body = raw.body || raw.note || raw.title || "Продолжаем!";
    return { type: "insight", id, title: raw.title || "Инсайт", body };
  }

  if (raw.type === "insight") {
    const id = raw.id || `ins_${raw.title || "insight"}`;
    return { type: "insight", id, title: raw.title || "Инсайт", body: raw.body };
  }

  return null;
}

/** Проверка заполненности шага */
function isAnswered(a: Answers, step: NStep): boolean {
  const v = a[step.id];
  switch (step.type) {
    case "text":   return typeof v === "string" && v.trim().length > 0;
    case "single": return typeof v === "string" && v.length > 0;
    case "multi":  return Array.isArray(v) && v.length > 0;
    case "scale":  return typeof v === "number";
    case "insight":return true;
    default:       return true;
  }
}

type S = { idx: number; answers: Answers };
const initial = (): S => ({ idx: 0, answers: loadAnswers() || {} });

export default function Quiz() {
  const [state, setState] = useState<S>(initial);

  // Нормализуем любые шаги из STEPS
  const steps = useMemo<NStep[]>(
    () => (Array.isArray(STEPS) ? STEPS.map(normalizeStep).filter(Boolean) as NStep[] : []),
    []
  );

  const total = steps.length;
  const step = steps[state.idx];

  useEffect(() => { saveAnswers(state.answers); }, [state.answers]);

  if (!step) return null;

  const pct = Math.round(((state.idx + 1) / total) * 100);

  const goNext = () => setState(s => ({ ...s, idx: Math.min(total - 1, s.idx + 1) }));
  const goPrev = () => setState(s => ({ ...s, idx: Math.max(0, s.idx - 1) }));
  const setValue = (val: any) => setState(s => ({ ...s, answers: { ...s.answers, [step.id]: val } }));

  const Field = (() => {
    switch (step.type) {
      case "text":
        return (
          <input
            autoFocus
            value={state.answers[step.id] ?? ""}
            onChange={e => setValue(e.target.value)}
            placeholder={step.placeholder || ""}
            className="w-full rounded-2xl border border-indigo-300/70 focus:border-indigo-500 outline-none px-5 py-4 text-lg"
          />
        );
      case "single":
        return (
          <div className="grid gap-2">
            {(step.options || []).map(opt => {
              const active = state.answers[step.id] === opt;
              return (
                <button
                  key={opt}
                  onClick={() => setValue(opt)}
                  className={cx(
                    "text-left px-4 py-3 rounded-2xl border transition",
                    active ? "border-indigo-500 bg-indigo-50" : "border-zinc-200 hover:border-indigo-300"
                  )}
                >
                  {opt}
                </button>
              );
            })}
          </div>
        );
      case "multi":
        return (
          <div className="flex flex-wrap gap-2">
            {(step.options || []).map(opt => {
              const cur: string[] = Array.isArray(state.answers[step.id]) ? state.answers[step.id] : [];
              const active = cur.includes(opt);
              const toggle = () => {
                const next = active ? cur.filter(x => x !== opt) : [...cur, opt];
                if (step.limit && next.length > step.limit) return;
                setValue(next);
              };
              return (
                <button
                  type="button"
                  key={opt}
                  onClick={toggle}
                  className={cx(
                    "px-4 py-2 rounded-full border text-sm transition",
                    active ? "border-indigo-500 bg-indigo-50" : "border-zinc-200 hover:border-indigo-300"
                  )}
                >
                  {opt}
                </button>
              );
            })}
          </div>
        );
      case "scale":
        return (
          <div className="flex items-center gap-3">
            <input
              type="range"
              min={step.min ?? 0}
              max={step.max ?? 10}
              step={1}
              value={state.answers[step.id] ?? (step.min ?? 0)}
              onChange={e => setValue(Number(e.target.value))}
              className="w-full"
            />
            <div className="min-w-10 text-right font-semibold">
              {state.answers[step.id] ?? (step.min ?? 0)}
            </div>
          </div>
        );
      case "insight":
        return (
          <div className="text-zinc-700">
            {typeof step.body === "function" ? step.body(state.answers) : step.body}
          </div>
        );
      default:
        return null;
    }
  })();

  const canNext = isAnswered(state.answers, step);

  return (
    <div className="space-y-3">
      <div className="flex items-center justify-between text-zinc-600">
        <div>Шаг {state.idx + 1}/{total}</div>
        <div>{pct}%</div>
      </div>
      <div className="h-3 w-full rounded-full bg-white/70 shadow-inner">
        <div className="h-3 rounded-full bg-gradient-to-r from-indigo-500 to-fuchsia-500 transition-[width]" style={{ width: `${pct}%` }} />
      </div>

      <Card title={step.title} subtitle={step.subtitle}>
        <div className="space-y-5">
          {Field}
          <div className="flex items-center justify-between pt-1">
            <Button variant="ghost" onClick={goPrev} disabled={state.idx === 0}>Назад</Button>
            <Button onClick={goNext} disabled={!canNext}>{state.idx + 1 === total ? "Готово" : "Дальше"}</Button>
          </div>
        </div>
      </Card>
    </div>
  );
}
